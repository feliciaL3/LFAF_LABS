# Topic: Determinism in Finite Automata. Conversion from NDFA 2 DFA. Chomsky Hierarchy.

### Course: Formal Languages & Finite Automata

### Author: Lupascu Felicia, FAF-212, VAR 15
----------------------------------------------

## Overview
<p align="justify">&ensp;&ensp;&ensp; Both deterministic finite automata (DFA) and nondeterministic finite automata (NFA) are theoretical models of computation in computer science and automata theory. To understand and accept it, they use a regular language, which is a collection of strings that can be generated by a regular expression. A mechanism for displaying various types of processes is a finite automaton. Given that they both have comparable structural and functional characteristics, it can be compared to a state machine. The term "finite" denotes the fact that an automaton has a set of initial and final states. In other words, a process that is represented by an automaton has a start and end. <p>

<p align="justify">&ensp;&ensp;&ensp; Based on an automaton's structure, there are instances where multiple states can be reached with a single transition, leading to the appearance of nondeterminism. Determinism generally refers to how predictable a system is when discussing systems theory. The system becomes stochastic or non-deterministic if random variables are involved. <p>

<p align="justify">&ensp;&ensp;&ensp; A finite-state machine is referred to as a deterministic finite automaton (DFA) in automata theory if Each of its state transitions is uniquely determined by its source state and input symbol, and each state transition necessitates reading an input symbol.
These limitations are not necessary for a nondeterministic finite automaton (NFA), also known as a nondeterministic finite-state machine. Every DFA in particular is also an NFA. <p>

## Objectives:
1. Understand what an automaton is and what it can be used for.

2. Continuing the work in the same repository and the same project, the following need to be added:
    a. Provide a function in your grammar type/class that could classify the grammar based on Chomsky hierarchy.

    b. For this you can use the variant from the previous lab.

3. According to your variant number (by universal convention it is register ID), get the finite automaton definition and do the following tasks:

    a. Implement conversion of a finite automaton to a regular grammar.

    b. Determine whether your FA is deterministic or non-deterministic.

    c. Implement some functionality that would convert an NDFA to a DFA.

    d. Represent the finite automaton graphically (Optional, and can be considered as a __*bonus point*__):

    - You can use external libraries, tools or APIs to generate the figures/diagrams.

    - Your program needs to gather and send the data about the automaton and the lib/tool/API return the visual representation.

    ## Implementation description
<p align="justify">&ensp;&ensp;&ensp; To implement this laboratory work I selected Python language. Firstly, I created two classes, one for the grammar, and the second one for the  finite automata. <p>

#### Variant 15:
```
Q = {q0,q1,q2,q3},
∑ = {a,b,c},
F = {q3},
δ(q0,a) = q0,
δ(q1,b) = q2,
δ(q0,a) = q1,
δ(q2,a) = q2,
δ(q2,b) = q3,
δ(q2,c) = q0.
```
    
    
<p align="justify">&ensp;&ensp;&ensp;  For the first practically task (task 2)   I provided a function in my grammar type/class that could classify the grammar based on Chomsky hierarchy. I added comments and explanation directly in the code. <p>
    
    
```
     # Method that classifies the grammar based on its type
    def classify_grammar(self):
        # Check each production to determine the type of the grammar
        # Check if any production is of length greater than 2 or has invalid symbols, indicating a Type 2 grammar
        for nonTerminal in self.Vn:
            for production in self.P[nonTerminal]:
                if len(production) > 2 or not (
                        production[0] in self.Vt or production[0] in self.Vn) or (
                        len(production) == 2 and production[1] not in self.Vn):
                    return 'Type 2'

        # Check if any non-start nonterminal has more than one production, or if the production is not of the form
        # A -> a or A -> aB, indicating a Type 3 grammar
        for nonTerminal in self.Vn:
            if nonTerminal != self.S:
                if len(self.P[nonTerminal]) > 1 or not (
                        len(self.P[nonTerminal][0]) == 1 and (
                        self.P[nonTerminal][0][0] in self.Vt or self.P[nonTerminal][0][0] in self.Vn)):
                    return 'Type 3'

        # Check if any symbol outside of start symbol is used in a right-hand side, indicating a Type 0 grammar
        for nonTerminal in self.Vn:
            for production in self.P[nonTerminal]:
                for symbol in production:
                    if symbol not in self.Vt and symbol not in self.S:
                        return 'Type 0'

        # If none of the above conditions are met, the grammar is of Type 1
        return 'Type 1'
  ```
   
    
 ```
Variant 15
Q = {q0,q1,q2,q3},
∑ = {a,b,c},
F = {q3},
δ(q0,a) = q0,
δ(q1,b) = q2,
δ(q0,a) = q1,
δ(q2,a) = q2,
δ(q2,b) = q3,
δ(q2,c) = q0.
```
    
<p align="justify">&ensp;&ensp;&ensp; Next, I used my Variant for The task 3. to  Implement conversion of a finite automaton to a regular grammar. This code defines a method called convert_to_grammar() that takes in a Grammar object as input and returns a new Grammar object that represents the same language as the current object, but in a different format. <p>

```
    def convert_to_grammar(self, Grammar):
        # Step 1: Create a dictionary to hold the productions for each state
        P = {state: [] for state in self.states}
        # Step 2: Add a new start symbol S
        S = self.first_state + "'"
        P[S] = [self.first_state]
        # Step 3: Add ε-productions for each final state
        for accept_state in self.final_state:
            P[accept_state].append("ε")
        # Step 4: Add productions for each transition
        for q, a, p in self.transitions:
            P[q].append(a + p)
        # Step 5: Create lists of non-terminal and terminal symbols
        Vn = list(self.states) + [S]
        Vt = self.alphabet
        # Step 6: Create the grammar object and return it
        return Grammar(S, Vt, Vn, P)
 ```
   
<p align="justify">&ensp;&ensp;&ensp; Task 3.b. Determine whether your FA is deterministic or non-deterministic. <p>
 ```
    def is_deterministic(self):
        # Step 1: Create a dictionary to hold the transitions for each state
        transitions = {}
        # Step 2: Loop through each transition and add it to the dictionary
        for transition in self.transitions:
            if transition[0] in transitions:
                # If the current state already has a transition with the same symbol, it's not deterministic
                if transition[1] in transitions[transition[0]]:
                    return "IT IS NOT DETERMINISTIC"
                # Otherwise, add the transition symbol to the dictionary for this state
                else:
                    transitions[transition[0]].append(transition[1])
                    # If the current state doesn't have any transitions yet, add the transition to the dictionary
            else:
                transitions[transition[0]] = [transition[1]]
                # Step 3: If the function hasn't returned yet, the automaton is deterministic
        return "IT IS DETERMINISTIC"
```
    
    
<p align="justify">&ensp;&ensp;&ensp; Task 3c. Implement some functionality that would convert an NDFA to a DFA. Firstly, I needed two more functions for implimenting this task 1.Epsilon_Closure 2.Move <p>
    
 <p align="justify">&ensp;&ensp;&ensp;  The functions Move and Epsilon_Closure are necessary to convert a non-deterministic finite automaton (NFA) to a deterministic finite automaton (DFA) because DFAs do not allow for multiple transitions from a single state on the same input symbol, while NFAs do. <p>

 <p align="justify">&ensp;&ensp;&ensp; The Epsilon_Closure function is used to determine all states that can be reached from a given set of states through epsilon transitions, which are transitions that can be taken without consuming any input symbol. This is necessary because these epsilon transitions can lead to additional states that the NFA can be in, and thus need to be taken into account when determining the set of states that the DFA can be in. <p>

 <p align="justify">&ensp;&ensp;&ensp; The Move function is used to determine all states that can be reached from a given set of states on a given input symbol. This is necessary because a single input symbol in the DFA can only lead to one state, while in the NFA it can lead to multiple states. <p>

    
```
 def move(self, states, symbol, transitions):
        # Find all the states that can be reached using the given symbol
        # from any of the given states
        return {transition[2] for state in states for transition in transitions if
                transition[0] == state and transition[1] == symbol}
```
    
```
    def epsilon_closure(self, states, transitions):
        # Create a new set containing the initial states
        e_closure = set(states)
        # Create a queue to hold the current states to process
        queue = list(states)
        # Loop through the states in the queue
        while queue:
            # Get the next state to process
            state = queue.pop(0)
            # Find all the next states that can be reached using epsilon transitions
            next_states = [transition[2] for transition in transitions if
                           transition[0] == state and transition[1] == 'ε']
            # Find the new states that haven't been added to the epsilon closure yet
            new_states = set(next_states) - e_closure
            # Add the new states to the epsilon closure
            e_closure |= new_states
            # Add the new states to the queue to be processed
            queue.extend(new_states)
        # Return the final epsilon closure
        return e_closure
```





    
